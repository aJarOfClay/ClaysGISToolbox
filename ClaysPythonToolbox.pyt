# -*- coding: utf-8 -*-import arcpyimport osfrom datetime import datetimeimport requestsimport csvimport stringclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "Clay's GIS Python Toolbox"        # List of tool classes associated with this toolbox        self.tools = [BulkDownload]class BulkDownload(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Bulk Download"        self.description = """Download from a list a links to avoid all that clicking around! \nInput: list of URLs formatted as a line-separated .txt \nOutput: the requested files in a specified folder, with a list of any 'problem urls' if they occur"""        self.canRunInBackground = True    def getParameterInfo(self):        """Define parameter definitions"""        # Location of the list        param0 = arcpy.Parameter(            displayName = "Input List (line-separated .txt)",            name = "input_list",            datatype = "DEFile",            parameterType = "Required",            direction = "Input")                # Download directory        param1 = arcpy.Parameter(            displayName = "Output Directory",            name = "output_directory",            datatype = "DEFolder",            parameterType = "Required",            direction = "Output")        # TODO: add toggle for overwriting existing files        # TODO: add toggle for preserving directory structure        param0.filter.list = ['txt']        param1.defaulsEnvironmentName = arcpy.env.scratchFolder                params = [param0, param1]        return params    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        input_list = parameters[0].valueAsText        output_directory = parameters[1].valueAsText        # creating target directory if needed        try:            os.mkdir(output_directory)            arcpy.AddMessage("Created new directory " + output_directory)        except OSError:            arcpy.AddMessage("Using existing directory " + output_directory)        # make a list of URLs to look at        url_list = []        with open(input_list,'r',encoding='utf8') as f:            url_list = f.readlines()  # crack apart entries        for i in range(len(url_list)):            url_list[i] = url_list[i].replace('\n', '')  # strip off newlines        url_list = [i for i in url_list if i]  # strip out blank entries        # function for downloading each file        def download_file(file_url, target_folder):            r = requests.get(file_url, headers=headers)  # create HTTP response object            file_name = get_filename(file_url)            # send an HTTP request to the server and save the HTTP response in a response object called r            with open(os.path.join(target_folder, file_name), 'wb') as f:                # write the contents of the response (r.content) to a new file in binary mode.                f.write(r.content)            return 0        # make a "problem links" list in the output if needed        problem_url_list = os.path.join(output_directory, datetime.now().strftime('ProblemURLs_%Y-%m-%d_%H-%M-%S.txt'))        def add_problem_url(problem_url):            f = open(problem_url_list, "a")            f.write(problem_url + "\n")            f.close()        def get_filename(file_url):            i = len(file_url) - 1            first_letter = 0            while i >= 0:                if file_url[i] == "/":                    first_letter = i + 1                    break                else:                    i -= 1            temp_filename = file_url[first_letter:]            valid_chars = "-_.() %s%s" % (string.ascii_letters, string.digits)            true_filename = ''.join(c for c in temp_filename if c in valid_chars)            return true_filename        # download each file        current_url = 0        total_urls = len(url_list)        had_problem_urls = False        headers = {'User-Agent': "Clay's Bulk Downloader (claystestingaddress@gmail.com)"}        # Wikimedia commons (and probably others) won't allow requests without an identifying header        for url in url_list:            try:                current_url += 1                arcpy.AddMessage(datetime.now().strftime("%H:%M:%S") +                            " | Fetching '%s' (%d / %d)"                            % (url, current_url, total_urls))                download_file(url, output_directory)            # Invalid URL            except requests.exceptions.MissingSchema:                arcpy.AddWarning("Invalid URL")                add_problem_url(url)                had_problem_urls = True            except requests.exceptions.InvalidSchema:                arcpy.AddWarning("Invalid URL")                add_problem_url(url)                had_problem_urls = True            # Trouble connecting            except requests.exceptions.ConnectionError or socket.gaierror \                   or urllib3.exceptions.NewConnectionError or urllib3.exceptions.MaxRetryError:                arcpy.AddWarning("Could not connect")                add_problem_url(url)                had_problem_urls = True            # Other errors, fill in more as you see them happen            '''except requests.exceptions as error:                arcpy.AddWarning("Unaccounted error: %s" % error)                add_problem_url(url)                had_problem_urls = True'''        # end message        arcpy.AddMessage("Downloads complete! Check '%s' to see your files." % output_directory)        if had_problem_urls:            arcpy.AddWarning("File created at '%s' with a list of problem urls" % problem_url_list)        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return